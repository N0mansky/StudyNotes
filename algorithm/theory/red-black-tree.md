## 红黑树左旋
LEFT-ROTATE(T,x) 在红黑树红，将x节点的左树做一个旋转
1. 将x右边的引用赋值给变量y
2. 将y的左边子树的值赋给x的右子树，覆盖掉了y的引用
3. 将x的引用赋值给y左边子树
4. 将x的父引用赋值给y的父引用
5. 如果 x的父引用为空，则说明该x节点为root节点
6.      所以 把y设置为根节点
7. 如果 x等于x父节点的的左子树 (这里需要判断x是在他父节点的左边还是右边）
8.      则 把y的引用赋值给x父节点的左子树
9.      否则将y的的引用赋值给x的父节点的右树
10. 将x的引用设置为y的又树
11. 将y的的引用赋值给x的父引用

## 红黑树的插入和插入修复
RB-INSERT(T,z) 往树T里面插入z
1. 初始化变量y为空
2. 将root赋值给变量x
3. while x ≠ 空:
4.      将 x赋值给变量y
5.      if z的值小于 x的值:
6.            then: x的左节点赋值给x
7.            else: x的右节点赋值给x
8. 将y(即找到的适合z存放位置的父节点)作为z的父引用
9. if y = 空:
10.     then: 说明T为空,并将z设置为root节点
11. else if z < y:
12.        then: 说明插入的z小于y,则把z放在y的左树
13. else: 说明 z > y,则把z放在y的右树
14. 由于z的子节点成为了叶子节点,所以把 z的左树设置为空
15. 把z的右树设置为空
16. 由于红黑树规定每个叶子节点都是黑的,所以z节点就是红的,将z节点染色为红色
17. 执行RB-INSERT-FIXUP(T,z) 执行红黑树插入修复

## 红黑树的修复
RB-INSERT-FIXUP(T,z) 当z插入树的时候,修复T
1. while z的父节点为red时:
2.      if z的父节点 是 z的爷爷节点的左树:
3.            then: 将爷爷节点的右树(即叔叔节点)赋值给变量y
4.                  if 叔叔节点为红色:
5.                        then: 将z的父节点的颜色设置为黑色
6.                              将叔叔节点的颜色设置为黑色
7.                              将爷爷节点设置为红色
8.                              将爷爷节点赋值给z自己
9.                  elseif 叔叔节点为黑色,且z是父亲节点的右树:
10.                       then: 将父节点指向z自己
11.                             左旋转LEFT-RORATE(T,z)                                
12.                 else:  叔叔节点为黑色,且z是父亲节点的左树:
13.                       then: 将父节点设置为黑色
14.                             将爷爷节点设置为红色
15.                             RIGHT-RORATE(T,爷爷节点)



                        
